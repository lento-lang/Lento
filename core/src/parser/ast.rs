use crate::{
    interpreter::value::{RecordKey, Value},
    lexer::{lexer::InputSource, token::LineInfo},
};

use super::op::OperatorInfo;

#[derive(Debug, Clone)]
pub struct ParamAst {
    pub name: String,
    pub ty: Option<TypeAst>,
    pub info: LineInfo,
}

impl PartialEq for ParamAst {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name && self.ty == other.ty
    }
}

#[derive(Debug, Clone)]
pub enum TypeAst {
    Identifier(String, LineInfo),
}

impl TypeAst {
    pub fn print_sexpr(&self) -> String {
        match self {
            TypeAst::Identifier(name, _) => name.clone(),
        }
    }
}

impl PartialEq for TypeAst {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Identifier(l0, _), Self::Identifier(r0, _)) => l0 == r0,
        }
    }
}

/// The AST is a tree of nodes that represent the program.
/// All nodes are expressions, and the root node is the program itself.
/// The AST is generated by the parser, and then interpreted by the interpreter module or compiled.
#[derive(Debug, Clone)]
pub enum Ast {
    /// A literal is a constant value that is directly represented in the source code.
    /// 1. Value of the literal
    Literal(Value, LineInfo),
    /// A tuple is a fixed-size collection of elements of possibly different types.
    /// 1. List of elements
    Tuple(Vec<Ast>, LineInfo),
    /// A dynamic list of elements.
    /// 1. List of elements
    /// 2. Type of every element in the list (all elements must **be a subtype**)
    List(Vec<Ast>, LineInfo),
    /// A record is a collection of key-value pairs
    /// 1. List of key-value pairs
    Record(Vec<(RecordKey, Ast)>, LineInfo),
    /// An identifier is a named reference to a value in the environment
    /// 1. Name of the identifier
    Identifier(String, LineInfo),
    /// A function call is an invocation of a function with a list of arguments
    /// 1. Name of the function
    /// 2. List of arguments
    Call(Box<Ast>, Box<Ast>, LineInfo),
    /// A function declaration is a named function with a list of parameters and a body expression
    Function {
        param: ParamAst,
        body: Box<Ast>,
        return_type: Option<TypeAst>,
        info: LineInfo,
    },
    /// An accumulate expression is an operation with multiple operands
    /// 1. Operator
    /// 2. List of operands
    Accumulate(OperatorInfo, Vec<Ast>, LineInfo),
    /// A binary expression is an operation with two operands
    /// 1. Left operand
    /// 2. Operator
    /// 3. Right operand
    Binary(Box<Ast>, OperatorInfo, Box<Ast>, LineInfo),
    /// A unary expression is an operation with one operand
    /// 1. Operator
    /// 2. Operand
    Unary(OperatorInfo, Box<Ast>, LineInfo),
    /// An assignment expression assigns a value to a variable
    /// 1. Matching pattern (identifier, destructuring of a tuple, record, etc.)
    /// 2. Value
    Assignment(Box<Ast>, Box<Ast>, LineInfo),
    /// Block expression evaluates all expressions in the block and returns the value of the last expression.
    /// 1. List of expressions
    Block(Vec<Ast>, LineInfo),
}

impl Ast {
    pub fn info(&self) -> &LineInfo {
        match self {
            Ast::Literal(_, info) => info,
            Ast::Tuple(_, info) => info,
            Ast::List(_, info) => info,
            Ast::Record(_, info) => info,
            Ast::Identifier(_, info) => info,
            Ast::Call(_, _, info) => info,
            Ast::Function { info, .. } => info,
            Ast::Accumulate(_, _, info) => info,
            Ast::Binary(_, _, _, info) => info,
            Ast::Unary(_, _, info) => info,
            Ast::Assignment(_, _, info) => info,
            Ast::Block(_, info) => info,
        }
    }

    pub fn print_sexpr(&self) -> String {
        match self {
            Ast::Literal(value, _) => value.pretty_print(),
            Ast::Tuple(elements, _) => format!(
                "({})",
                elements
                    .iter()
                    .map(|e| e.print_sexpr())
                    .collect::<Vec<String>>()
                    .join(" ")
            ),
            Ast::List(elements, _) => format!(
                "[{}]",
                elements
                    .iter()
                    .map(|e| e.print_sexpr())
                    .collect::<Vec<String>>()
                    .join(" ")
            ),
            Ast::Record(_elements, _) => todo!(),
            Ast::Identifier(name, _) => name.clone(),
            Ast::Call(expr, arg, _) => format!("{}({})", expr.print_sexpr(), arg.print_sexpr()),
            Ast::Function {
                param: params,
                body,
                ..
            } => {
                if let Some(ty) = &params.ty {
                    format!(
                        "({} {} -> {})",
                        params.name,
                        ty.print_sexpr(),
                        body.print_sexpr()
                    )
                } else {
                    format!("(unknown {} -> {})", params.name, body.print_sexpr())
                }
            }
            Ast::Accumulate(op, operands, _) => {
                format!(
                    "({} {})",
                    op.symbol.clone(),
                    operands
                        .iter()
                        .map(|e| e.print_sexpr())
                        .collect::<Vec<String>>()
                        .join(" ")
                )
            }
            Ast::Binary(lhs, op, rhs, _) => format!(
                "({} {} {})",
                op.symbol.clone(),
                lhs.print_sexpr(),
                rhs.print_sexpr()
            ),
            Ast::Unary(op, operand, _) => {
                format!("({} {})", op.symbol.clone(), operand.print_sexpr())
            }
            Ast::Assignment(lhs, rhs, _) => {
                format!("(= {} {})", lhs.print_sexpr(), rhs.print_sexpr())
            }
            Ast::Block(expressions, _) => format!(
                "({})",
                expressions
                    .iter()
                    .map(|e| e.print_sexpr())
                    .collect::<Vec<String>>()
                    .join(" ")
            ),
        }
    }
}

impl PartialEq for Ast {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Literal(l0, _), Self::Literal(r0, _)) => l0 == r0,
            (Self::Tuple(l0, _), Self::Tuple(r0, _)) => l0 == r0,
            (Self::List(l0, _), Self::List(r0, _)) => l0 == r0,
            (Self::Record(l0, _), Self::Record(r0, _)) => l0 == r0,
            (Self::Identifier(l0, _), Self::Identifier(r0, _)) => l0 == r0,
            (Self::Call(l0, l1, _), Self::Call(r0, r1, _)) => l0 == r0 && l1 == r1,
            (
                Self::Function {
                    param: l_param,
                    body: l_body,
                    return_type: l_return_type,
                    ..
                },
                Self::Function {
                    param: r_param,
                    body: r_body,
                    return_type: r_return_type,
                    ..
                },
            ) => l_param == r_param && l_body == r_body && l_return_type == r_return_type,
            (Self::Accumulate(l0, l1, _), Self::Accumulate(r0, r1, _)) => l0 == r0 && l1 == r1,
            (Self::Binary(l0, l1, l2, _), Self::Binary(r0, r1, r2, _)) => {
                l0 == r0 && l2 == r2 && l1 == r1
            }
            (Self::Unary(l0, l1, _), Self::Unary(r0, r1, _)) => l0 == r0 && l1 == r1,
            (Self::Assignment(l0, l1, _), Self::Assignment(r0, r1, _)) => l0 == r0 && l1 == r1,
            (Self::Block(l0, _), Self::Block(r0, _)) => l0 == r0,
            _ => false,
        }
    }
}

/// Module is the root program node of the AST
/// It contains a list of all the expressions in the program
#[derive(Debug, Clone)]
pub struct Module {
    pub name: String,
    pub expressions: Vec<Ast>,
    pub source: InputSource,
}

impl Module {
    pub fn new(name: String, expressions: Vec<Ast>, source: InputSource) -> Module {
        Module {
            name,
            expressions,
            source,
        }
    }
}
